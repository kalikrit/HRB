# Техническое задание: "Heavy Render Benchmark"

## 1. Общее описание
Создается full-stack веб-проект для сравнительного анализа производительности рендеринга трех современных фронтенд-фреймворков: **React**, **Vue 3** и **Svelte**. Все фреймворки взаимодействуют с единым бэкендом на **FastAPI (Python)**, получая идентичные "тяжелые" наборы данных и измеряя метрики производительности при их отображении.

**Цель:** Создать научный инструмент для оценки производительности фреймворков в стресс-сценариях рендеринга больших объемов сложных данных.

**Основной сценарий:** Пользователь через UI каждого фронтенд-приложения запускает синтетический тест ("Start Benchmark"), который:
1.  Запрашивает у бэкенда сгенерированный массив сложных объектов (конфигурируемый размер, обычно 1000+ элементов)
2.  Получает данные и выполняет их полный рендеринг в DOM
3.  В реальном времени измеряет и визуализирует ключевые метрики производительности

## 2. Архитектура системы

### 2.1. Backend (FastAPI)
*   **Роль:** Нейтральный генератор данных для тестирования.
*   **Эндпоинт:**
    *   `POST /api/benchmark/start`
    *   **Тело запроса (JSON):**
        ```json
        {
          "framework": "react | vue | svelte",
          "payloadSize": 1000,
          "complexity": "low | medium | high"
        }
        ```
    *   **Ответ:** Массив из `payloadSize` объектов `BenchmarkItem`.
*   **Структура данных `BenchmarkItem`:**
    *   **Простой набор (complexity="low"):** 10-20 плоских полей различных типов (`id`, `name`, `value`, `isActive`, `timestamp`, `tags[]`, `progress`).
    *   **Сложный набор (complexity="high"):** Вложенная структура с объектами и массивами (например, `user: {name, avatar, contacts[]}`, `stats: {level, health, inventory[]}`, `history: event[]`). Призван создать нагрузку на систему реактивности фреймворков.
*   **Технологии:**
    *   **Язык:** Python 3.10+
    *   **Фреймворк:** FastAPI
    *   **Генерация данных:** Библиотека `Faker` (или кастомный генератор)
    *   **Сервер:** Uvicorn (для разработки), Gunicorn (для production)
    *   **CORS:** Должен быть настроен для доменов/портов всех трех фронтенд-приложений.

### 2.2. Frontend (3 независимых приложения)
Каждое приложение — полностью автономный проект с идентичным пользовательским интерфейсом и логикой измерений.

*   **Общий UI-макет:**
    1.  **Панель управления:** Поля для выбора `payloadSize` и `complexity`. Две кнопки запуска: **"Test Out-of-the-Box (OOTB)"** и **"Test Optimized"**.
    2.  **Основная область:** Изначально пустая, используется для рендеринга полученного массива данных (например, в виде таблицы, сетки карточек или списка).
    3.  **Панель метрик:** Область для отображения измеренных показателей в реальном времени (цифры и графики).
    4.  **График производительности:** Canvas/SVG-график, отображающий FPS или время рендеринга по мере выполнения теста.
*   **Технологический стек для каждого фреймворка:**
    *   **React:** Create React App (или Vite + React), хуки (`useState`, `useEffect`), для оптимизированного теста — `React.memo`, `useMemo`.
    *   **Vue 3:** Композиционный API (`ref`, `reactive`, `computed`), для оптимизированного теста — `v-memo`, `computed`, функциональные компоненты.
    *   **Svelte:** SvelteKit (или Vite + Svelte), встроенная реактивность. Оптимизации во многом ложатся на компилятор.
*   **Обязательная общая библиотека (опционально, но рекомендуется):** Отдельный npm-пакет или модуль с единой, тщательно выверенной логикой измерений (расчет FPS, времени), подключаемый ко всем трем проектам для обеспечения честности сравнения.

## 3. Логика работы и измерения производительности

### 3.1. Последовательность выполнения теста
1.  **Инициализация:** Пользователь выбирает параметры и нажимает кнопку запуска.
2.  **Сброс:** Очистка предыдущих данных и результатов измерений.
3.  **Запрос данных:** Отправка `POST /api/benchmark/start`. Фиксация времени `networkStart`.
4.  **Получение данных:** Фиксация времени `dataReceived`. При необходимости — замер времени парсинга JSON.
5.  **Подготовка данных:** Конвертация данных для состояния приложения. Фиксация времени `processEnd`.
6.  **Рендеринг:** Запуск основного цикла отрисовки массива. Фиксация времени `renderStart` и `renderEnd`.
7.  **Сбор метрик:** Расчет всех показателей, обновление UI.

### 3.2. Измеряемые метрики (для отображения в UI)
*   **Network Time (мс):** `dataReceived - networkStart`.
*   **Data Processing Time (мс):** `processEnd - dataReceived`.
*   **Render Time (мс):** `renderEnd - renderStart`. **Главная метрика.**
*   **Total Time (мс):** `renderEnd - networkStart`.
*   **FPS (средний/минимальный):** Количество кадров в секунду, рассчитанное во время выполнения рендеринга (чезу `requestAnimationFrame`).
*   **Memory Delta (MB, опционально):** Разница в использовании памяти до и после теста (через `performance.memory` в Chrome).
*   **Bundle Size (статично):** Размер production-сборки каждого приложения (для справочного сравнения).

### 3.3. Критерии честного сравнения
*   **Production-сборка:** Все тесты выполняются исключительно на production-сборках фронтенд-приложений (без dev-мод).
*   **Одинаковые условия:** Тесты проводятся в одном браузере (Chrome/Chromium), на одной машине.
*   **Статистическая значимость:** Реализация кнопки **"Run 10 iterations"** для автоматического прогона серии тестов и вычисления средних значений/погрешности.
*   **Разделение стратегий:** Четкое разделение тестов "из коробки" (базовый рендеринг) и "с оптимизациями" (использование встроенных в фреймворк best practices).

## 4. Требования к окружению и развертыванию

### 4.1. Разработка (Ubuntu 24.04 LTS)
*   **Python 3.10+ и окружение:** `python3-venv`, `pip`
*   **Node.js 18+ и npm:** Установка через официальный PPA или менеджер версий `nvm`.
*   **Глобальные пакеты:** `@vue/cli` (опционально, можно использовать `create-vue`), `create-react-app` (или использование `npx`), `sv` (для SvelteKit).
*   **Рекомендуемая структура проекта (monorepo):**
    ```
    /heavy-render-benchmark
        /backend           # FastAPI приложение
            /app
                main.py    # Основной файл с эндпоинтами
            requirements.txt
        /frontends
            /react-app
            /vue-app
            /svelte-app
        /docs              # Документация по запуску и методологии
        docker-compose.yml
        README.md
    ```

### 4.2. Запуск для разработки и тестирования
*   **Бэкенд:** `cd backend && uvicorn app.main:app --reload --host 0.0.0.0 --port 8000`
*   **Фронтенд (React):** `cd frontends/react-app && npm start` (порт 3000)
*   **Фронтенд (Vue):** `cd frontends/vue-app && npm run dev` (порт 5173)
*   **Фронтенд (Svelte):** `cd frontends/svelte-app && npm run dev` (порт 5174)

### 4.3. Продакшн-развертывание (вариант)
*   **Фронтенды:** Сборка командой `npm run build`. Статические файлы обслуживаются Nginx.
*   **Бэкенд:** Запуск через `gunicorn` за reverse proxy (Nginx).
*   **Контейнеризация (рекомендуется):** Создание Dockerfile для каждого сервиса и оркестрация через `docker-compose.yml` для простоты развертывания.

## 5. Критерии успеха и результат
*   **Рабочий инструмент:** Полностью функционирующая система, где каждое из трех фронтенд-приложений может провести тест и наглядно отобразить метрики.
*   **Чистота эксперимента:** Обеспечена идентичность данных, логики измерений и условий выполнения теста во всех фреймворках.
*   **Наглядность результата:** UI позволяет легко интерпретировать цифровые метрики и графики, сравнивая производительность.
*   **Воспроизводимость:** Проект легко развернуть на другой машине (благодаря детальной документации и, желательно, контейнеризации).

## 6. Нефункциональные требования
*   **Производительность:** Логика замера производительности сама должна иметь минимальные накладные расходы.
*   **Удобство разработки:** Проект должен быть удобен для изучения и модификации (четкая структура, комментарии).
*   **Документация:** Подробный README с инструкциями по установке, запуску и интерпретации результатов.

---
*Это техническое задание описывает минимальный жизнеспособный продукт (MVP). Дальнейшее развитие может включать тестирование дополнительных фреймворков (Solid.js, Qwik), более сложные сценарии рендеринга (интерактивные элементы, анимации) или детальный анализ потребления памяти.*
